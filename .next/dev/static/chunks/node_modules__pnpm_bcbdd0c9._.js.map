{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 13, "column": 0}, "map": {"version":3,"sources":["file:///home/anh/to-do-list/node_modules/.pnpm/%40iota%2Bbcs%401.4.0/node_modules/%40iota/bcs/src/b64.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nexport function fromBase64(base64String: string): Uint8Array {\n    return Uint8Array.from(atob(base64String), (char) => char.charCodeAt(0));\n}\n\nconst CHUNK_SIZE = 8192;\nexport function toBase64(bytes: Uint8Array): string {\n    // Special-case the simple case for speed's sake.\n    if (bytes.length < CHUNK_SIZE) {\n        return btoa(String.fromCharCode(...bytes));\n    }\n\n    let output = '';\n    for (let i = 0; i < bytes.length; i += CHUNK_SIZE) {\n        const chunk = bytes.slice(i, i + CHUNK_SIZE);\n        output += String.fromCharCode(...chunk);\n    }\n\n    return btoa(output);\n}\n\n/** @deprecated use toBase64 instead */\nexport const toB64 = toBase64;\n\n/** @deprecated use fromBase64 instead */\nexport const fromB64 = fromBase64;\n"],"names":[],"mappings":";;;;;;;;;;AAIO,SAAS,WAAW,YAAA,EAAkC;IACzD,OAAO,WAAW,IAAA,CAAK,KAAK,YAAY,GAAG,CAAC,OAAS,KAAK,UAAA,CAAW,CAAC,CAAC;AAC3E;AAEA,MAAM,aAAa;AACZ,SAAS,SAAS,KAAA,EAA2B;IAEhD,IAAI,MAAM,MAAA,GAAS,YAAY;QAC3B,OAAO,KAAK,OAAO,YAAA,CAAa,GAAG,KAAK,CAAC;IAC7C;IAEA,IAAI,SAAS;IACb,IAAA,IAAS,IAAI,GAAG,IAAI,MAAM,MAAA,EAAQ,KAAK,WAAY;QAC/C,MAAM,QAAQ,MAAM,KAAA,CAAM,GAAG,IAAI,UAAU;QAC3C,UAAU,OAAO,YAAA,CAAa,GAAG,KAAK;IAC1C;IAEA,OAAO,KAAK,MAAM;AACtB;AAGO,MAAM,QAAQ;AAGd,MAAM,UAAU"}},
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///home/anh/to-do-list/node_modules/.pnpm/%40iota%2Bbcs%401.4.0/node_modules/%40iota/bcs/src/b58.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport bs58 from 'bs58';\n\nexport const toBase58 = (buffer: Uint8Array) => bs58.encode(buffer);\nexport const fromBase58 = (str: string) => bs58.decode(str);\n\n/** @deprecated use toBase58 instead */\nexport const toB58 = toBase58;\n\n/** @deprecated use fromBase58 instead */\nexport const fromB58 = fromBase58;\n"],"names":[],"mappings":";;;;;;;;;;AAIA,OAAO,UAAU;;AAEV,MAAM,WAAW,CAAC,SAAuB,0MAAA,CAAK,MAAA,CAAO,MAAM;AAC3D,MAAM,aAAa,CAAC,MAAgB,0MAAA,CAAK,MAAA,CAAO,GAAG;AAGnD,MAAM,QAAQ;AAGd,MAAM,UAAU"}},
    {"offset": {"line": 68, "column": 0}, "map": {"version":3,"sources":["file:///home/anh/to-do-list/node_modules/.pnpm/%40iota%2Bbcs%401.4.0/node_modules/%40iota/bcs/src/hex.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nexport function fromHex(hexStr: string): Uint8Array {\n    const normalized = hexStr.startsWith('0x') ? hexStr.slice(2) : hexStr;\n    const padded = normalized.length % 2 === 0 ? normalized : `0${normalized}}`;\n    const intArr = padded.match(/.{2}/g)?.map((byte) => parseInt(byte, 16)) ?? [];\n\n    return Uint8Array.from(intArr);\n}\n\nexport function toHex(bytes: Uint8Array): string {\n    return bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n}\n\n/** @deprecated use toHex instead */\nexport const toHEX = toHex;\n\n/** @deprecated use fromHex instead */\nexport const fromHEX = fromHex;\n"],"names":[],"mappings":";;;;;;;;;;AAIO,SAAS,QAAQ,MAAA,EAA4B;IAChD,MAAM,aAAa,OAAO,UAAA,CAAW,IAAI,IAAI,OAAO,KAAA,CAAM,CAAC,IAAI;IAC/D,MAAM,SAAS,WAAW,MAAA,GAAS,MAAM,IAAI,aAAa,CAAA,CAAA,EAAI,UAAU,CAAA,CAAA,CAAA;IACxE,MAAM,SAAS,OAAO,KAAA,CAAM,OAAO,GAAG,IAAI,CAAC,OAAS,SAAS,MAAM,EAAE,CAAC,KAAK,CAAC,CAAA;IAE5E,OAAO,WAAW,IAAA,CAAK,MAAM;AACjC;AAEO,SAAS,MAAM,KAAA,EAA2B;IAC7C,OAAO,MAAM,MAAA,CAAO,CAAC,KAAK,OAAS,MAAM,KAAK,QAAA,CAAS,EAAE,EAAE,QAAA,CAAS,GAAG,GAAG,GAAG,EAAE;AACnF;AAGO,MAAM,QAAQ;AAGd,MAAM,UAAU"}},
    {"offset": {"line": 95, "column": 0}, "map": {"version":3,"sources":["file:///home/anh/to-do-list/node_modules/.pnpm/%40iota%2Bbcs%401.4.0/node_modules/%40iota/bcs/src/uleb.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\n// Helper utility: write number as an ULEB array.\n// Original code is taken from: https://www.npmjs.com/package/uleb128 (no longer exists)\nexport function ulebEncode(num: number): number[] {\n    const arr = [];\n    let len = 0;\n\n    if (num === 0) {\n        return [0];\n    }\n\n    while (num > 0) {\n        arr[len] = num & 0x7f;\n        if ((num >>= 7)) {\n            arr[len] |= 0x80;\n        }\n        len += 1;\n    }\n\n    return arr;\n}\n\n// Helper utility: decode ULEB as an array of numbers.\n// Original code is taken from: https://www.npmjs.com/package/uleb128 (no longer exists)\nexport function ulebDecode(arr: number[] | Uint8Array): {\n    value: number;\n    length: number;\n} {\n    let total = 0;\n    let shift = 0;\n    let len = 0;\n\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        const byte = arr[len];\n        len += 1;\n        total |= (byte & 0x7f) << shift;\n        if ((byte & 0x80) === 0) {\n            break;\n        }\n        shift += 7;\n    }\n\n    return {\n        value: total,\n        length: len,\n    };\n}\n"],"names":[],"mappings":";;;;;;AAMO,SAAS,WAAW,GAAA,EAAuB;IAC9C,MAAM,MAAM,CAAC,CAAA;IACb,IAAI,MAAM;IAEV,IAAI,QAAQ,GAAG;QACX,OAAO;YAAC,CAAC;SAAA;IACb;IAEA,MAAO,MAAM,EAAG;QACZ,GAAA,CAAI,GAAG,CAAA,GAAI,MAAM;QACjB,IAAK,QAAQ,GAAI;YACb,GAAA,CAAI,GAAG,CAAA,IAAK;QAChB;QACA,OAAO;IACX;IAEA,OAAO;AACX;AAIO,SAAS,WAAW,GAAA,EAGzB;IACE,IAAI,QAAQ;IACZ,IAAI,QAAQ;IACZ,IAAI,MAAM;IAGV,MAAO,KAAM;QACT,MAAM,OAAO,GAAA,CAAI,GAAG,CAAA;QACpB,OAAO;QACP,SAAA,CAAU,OAAO,GAAA,KAAS;QAC1B,IAAA,CAAK,OAAO,GAAA,MAAU,GAAG;YACrB;QACJ;QACA,SAAS;IACb;IAEA,OAAO;QACH,OAAO;QACP,QAAQ;IACZ;AACJ"}},
    {"offset": {"line": 142, "column": 0}, "map": {"version":3,"sources":["file:///home/anh/to-do-list/node_modules/.pnpm/%40iota%2Bbcs%401.4.0/node_modules/%40iota/bcs/src/reader.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { ulebDecode } from './uleb.js';\n\n/**\n * Class used for reading BCS data chunk by chunk. Meant to be used\n * by some wrapper, which will make sure that data is valid and is\n * matching the desired format.\n *\n * @example\n * // data for this example is:\n * // { a: u8, b: u32, c: bool, d: u64 }\n *\n * let reader = new BcsReader(\"647f1a060001ffffe7890423c78a050102030405\");\n * let field1 = reader.read8();\n * let field2 = reader.read32();\n * let field3 = reader.read8() === '1'; // bool\n * let field4 = reader.read64();\n * // ....\n *\n * Reading vectors is another deal in bcs. To read a vector, you first need to read\n * its length using {@link readULEB}. Here's an example:\n * @example\n * // data encoded: { field: [1, 2, 3, 4, 5] }\n * let reader = new BcsReader(\"050102030405\");\n * let vec_length = reader.readULEB();\n * let elements = [];\n * for (let i = 0; i < vec_length; i++) {\n *   elements.push(reader.read8());\n * }\n * console.log(elements); // [1,2,3,4,5]\n *\n * @param {String} data HEX-encoded data (serialized BCS)\n */\nexport class BcsReader {\n    private dataView: DataView;\n    private bytePosition: number = 0;\n\n    /**\n     * @param {Uint8Array} data Data to use as a buffer.\n     */\n    constructor(data: Uint8Array) {\n        this.dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);\n    }\n    /**\n     * Shift current cursor position by `bytes`.\n     *\n     * @param {Number} bytes Number of bytes to\n     * @returns {this} Self for possible chaining.\n     */\n    shift(bytes: number) {\n        this.bytePosition += bytes;\n        return this;\n    }\n    /**\n     * Read U8 value from the buffer and shift cursor by 1.\n     * @returns\n     */\n    read8(): number {\n        const value = this.dataView.getUint8(this.bytePosition);\n        this.shift(1);\n        return value;\n    }\n    /**\n     * Read U16 value from the buffer and shift cursor by 2.\n     * @returns\n     */\n    read16(): number {\n        const value = this.dataView.getUint16(this.bytePosition, true);\n        this.shift(2);\n        return value;\n    }\n    /**\n     * Read U32 value from the buffer and shift cursor by 4.\n     * @returns\n     */\n    read32(): number {\n        const value = this.dataView.getUint32(this.bytePosition, true);\n        this.shift(4);\n        return value;\n    }\n    /**\n     * Read U64 value from the buffer and shift cursor by 8.\n     * @returns\n     */\n    read64(): string {\n        const value1 = this.read32();\n        const value2 = this.read32();\n\n        const result = value2.toString(16) + value1.toString(16).padStart(8, '0');\n\n        return BigInt('0x' + result).toString(10);\n    }\n    /**\n     * Read U128 value from the buffer and shift cursor by 16.\n     */\n    read128(): string {\n        const value1 = BigInt(this.read64());\n        const value2 = BigInt(this.read64());\n        const result = value2.toString(16) + value1.toString(16).padStart(16, '0');\n\n        return BigInt('0x' + result).toString(10);\n    }\n    /**\n     * Read U128 value from the buffer and shift cursor by 32.\n     * @returns\n     */\n    read256(): string {\n        const value1 = BigInt(this.read128());\n        const value2 = BigInt(this.read128());\n        const result = value2.toString(16) + value1.toString(16).padStart(32, '0');\n\n        return BigInt('0x' + result).toString(10);\n    }\n    /**\n     * Read `num` number of bytes from the buffer and shift cursor by `num`.\n     * @param num Number of bytes to read.\n     */\n    readBytes(num: number): Uint8Array {\n        const start = this.bytePosition + this.dataView.byteOffset;\n        const value = new Uint8Array(this.dataView.buffer, start, num);\n\n        this.shift(num);\n\n        return value;\n    }\n    /**\n     * Read ULEB value - an integer of varying size. Used for enum indexes and\n     * vector lengths.\n     * @returns {Number} The ULEB value.\n     */\n    readULEB(): number {\n        const start = this.bytePosition + this.dataView.byteOffset;\n        const buffer = new Uint8Array(this.dataView.buffer, start);\n        const { value, length } = ulebDecode(buffer);\n\n        this.shift(length);\n\n        return value;\n    }\n    /**\n     * Read a BCS vector: read a length and then apply function `cb` X times\n     * where X is the length of the vector, defined as ULEB in BCS bytes.\n     * @param cb Callback to process elements of vector.\n     * @returns {Array<Any>} Array of the resulting values, returned by callback.\n     */\n    readVec(cb: (reader: BcsReader, i: number, length: number) => any): any[] {\n        const length = this.readULEB();\n        const result = [];\n        for (let i = 0; i < length; i++) {\n            result.push(cb(this, i, length));\n        }\n        return result;\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 254, "column": 0}, "map": {"version":3,"sources":["file:///home/anh/to-do-list/node_modules/.pnpm/%40iota%2Bbcs%401.4.0/node_modules/%40iota/bcs/src/utils.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase58, toBase58 } from './b58.js';\nimport { fromBase64, toBase64 } from './b64.js';\nimport { fromHex, toHex } from './hex.js';\nimport type { Encoding } from './types.js';\n\n/**\n * Encode data with either `hex` or `base64`.\n *\n * @param {Uint8Array} data Data to encode.\n * @param {String} encoding Encoding to use: base64 or hex\n * @return {String} Encoded value.\n */\nexport function encodeStr(data: Uint8Array, encoding: Encoding): string {\n    switch (encoding) {\n        case 'base58':\n            return toBase58(data);\n        case 'base64':\n            return toBase64(data);\n        case 'hex':\n            return toHex(data);\n        default:\n            throw new Error('Unsupported encoding, supported values are: base64, hex');\n    }\n}\n\n/**\n * Decode either `base64` or `hex` data.\n *\n * @param {String} data Data to encode.\n * @param {String} encoding Encoding to use: base64 or hex\n * @return {Uint8Array} Encoded value.\n */\nexport function decodeStr(data: string, encoding: Encoding): Uint8Array {\n    switch (encoding) {\n        case 'base58':\n            return fromBase58(data);\n        case 'base64':\n            return fromBase64(data);\n        case 'hex':\n            return fromHex(data);\n        default:\n            throw new Error('Unsupported encoding, supported values are: base64, hex');\n    }\n}\n\nexport function splitGenericParameters(\n    str: string,\n    genericSeparators: [string, string] = ['<', '>'],\n) {\n    const [left, right] = genericSeparators;\n    const tok = [];\n    let word = '';\n    let nestedAngleBrackets = 0;\n\n    for (let i = 0; i < str.length; i++) {\n        const char = str[i];\n        if (char === left) {\n            nestedAngleBrackets++;\n        }\n        if (char === right) {\n            nestedAngleBrackets--;\n        }\n        if (nestedAngleBrackets === 0 && char === ',') {\n            tok.push(word.trim());\n            word = '';\n            continue;\n        }\n        word += char;\n    }\n\n    tok.push(word.trim());\n\n    return tok;\n}\n"],"names":[],"mappings":";;;;;;;;AAIA,SAAS,YAAY,gBAAgB;AACrC,SAAS,YAAY,gBAAgB;AACrC,SAAS,SAAS,aAAa;;;;AAUxB,SAAS,UAAU,IAAA,EAAkB,QAAA,EAA4B;IACpE,OAAQ,UAAU;QACd,KAAK;YACD,WAAO,4NAAA,EAAS,IAAI;QACxB,KAAK;YACD,WAAO,4NAAA,EAAS,IAAI;QACxB,KAAK;YACD,WAAO,yNAAA,EAAM,IAAI;QACrB;YACI,MAAM,IAAI,MAAM,yDAAyD;IACjF;AACJ;AASO,SAAS,UAAU,IAAA,EAAc,QAAA,EAAgC;IACpE,OAAQ,UAAU;QACd,KAAK;YACD,WAAO,8NAAA,EAAW,IAAI;QAC1B,KAAK;YACD,WAAO,8NAAA,EAAW,IAAI;QAC1B,KAAK;YACD,WAAO,2NAAA,EAAQ,IAAI;QACvB;YACI,MAAM,IAAI,MAAM,yDAAyD;IACjF;AACJ;AAEO,SAAS,uBACZ,GAAA,EACA,oBAAsC;IAAC;IAAK,GAAG;CAAA,EACjD;IACE,MAAM,CAAC,MAAM,KAAK,CAAA,GAAI;IACtB,MAAM,MAAM,CAAC,CAAA;IACb,IAAI,OAAO;IACX,IAAI,sBAAsB;IAE1B,IAAA,IAAS,IAAI,GAAG,IAAI,IAAI,MAAA,EAAQ,IAAK;QACjC,MAAM,OAAO,GAAA,CAAI,CAAC,CAAA;QAClB,IAAI,SAAS,MAAM;YACf;QACJ;QACA,IAAI,SAAS,OAAO;YAChB;QACJ;QACA,IAAI,wBAAwB,KAAK,SAAS,KAAK;YAC3C,IAAI,IAAA,CAAK,KAAK,IAAA,CAAK,CAAC;YACpB,OAAO;YACP;QACJ;QACA,QAAQ;IACZ;IAEA,IAAI,IAAA,CAAK,KAAK,IAAA,CAAK,CAAC;IAEpB,OAAO;AACX"}},
    {"offset": {"line": 324, "column": 0}, "map": {"version":3,"sources":["file:///home/anh/to-do-list/node_modules/.pnpm/%40iota%2Bbcs%401.4.0/node_modules/%40iota/bcs/src/writer.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { Encoding } from './types.js';\nimport { ulebEncode } from './uleb.js';\nimport { encodeStr } from './utils.js';\n\nexport interface BcsWriterOptions {\n    /** The initial size (in bytes) of the buffer that will be allocated */\n    initialSize?: number;\n    /** The maximum size (in bytes) that the buffer is allowed to grow to */\n    maxSize?: number;\n    /** The amount of bytes that will be allocated whenever additional memory is required */\n    allocateSize?: number;\n}\n\n/**\n * Class used to write BCS data into a buffer. Initializer requires\n * some size of a buffer to init; default value for this buffer is 1KB.\n *\n * Most methods are chainable, so it is possible to write them in one go.\n *\n * @example\n * let serialized = new BcsWriter()\n *   .write8(10)\n *   .write32(1000000)\n *   .write64(10000001000000)\n *   .hex();\n */\n\n/**\n * Set of methods that allows data encoding/decoding as standalone\n * BCS value or a part of a composed structure/vector.\n */\nexport class BcsWriter {\n    private dataView: DataView;\n    private bytePosition: number = 0;\n    private size: number;\n    private maxSize: number;\n    private allocateSize: number;\n\n    constructor({\n        initialSize = 1024,\n        maxSize = Infinity,\n        allocateSize = 1024,\n    }: BcsWriterOptions = {}) {\n        this.size = initialSize;\n        this.maxSize = maxSize;\n        this.allocateSize = allocateSize;\n        this.dataView = new DataView(new ArrayBuffer(initialSize));\n    }\n\n    private ensureSizeOrGrow(bytes: number) {\n        const requiredSize = this.bytePosition + bytes;\n        if (requiredSize > this.size) {\n            const nextSize = Math.min(this.maxSize, this.size + this.allocateSize);\n            if (requiredSize > nextSize) {\n                throw new Error(\n                    `SizeLimitExceeded: Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${requiredSize}`,\n                );\n            }\n\n            this.size = nextSize;\n            const nextBuffer = new ArrayBuffer(this.size);\n            new Uint8Array(nextBuffer).set(new Uint8Array(this.dataView.buffer));\n            this.dataView = new DataView(nextBuffer);\n        }\n    }\n\n    /**\n     * Shift current cursor position by `bytes`.\n     *\n     * @param {Number} bytes Number of bytes to\n     * @returns {this} Self for possible chaining.\n     */\n    shift(bytes: number): this {\n        this.bytePosition += bytes;\n        return this;\n    }\n    /**\n     * Write a U8 value into a buffer and shift cursor position by 1.\n     * @param {Number} value Value to write.\n     * @returns {this}\n     */\n    write8(value: number | bigint): this {\n        this.ensureSizeOrGrow(1);\n        this.dataView.setUint8(this.bytePosition, Number(value));\n        return this.shift(1);\n    }\n    /**\n     * Write a U16 value into a buffer and shift cursor position by 2.\n     * @param {Number} value Value to write.\n     * @returns {this}\n     */\n    write16(value: number | bigint): this {\n        this.ensureSizeOrGrow(2);\n        this.dataView.setUint16(this.bytePosition, Number(value), true);\n        return this.shift(2);\n    }\n    /**\n     * Write a U32 value into a buffer and shift cursor position by 4.\n     * @param {Number} value Value to write.\n     * @returns {this}\n     */\n    write32(value: number | bigint): this {\n        this.ensureSizeOrGrow(4);\n        this.dataView.setUint32(this.bytePosition, Number(value), true);\n        return this.shift(4);\n    }\n    /**\n     * Write a U64 value into a buffer and shift cursor position by 8.\n     * @param {bigint} value Value to write.\n     * @returns {this}\n     */\n    write64(value: number | bigint): this {\n        toLittleEndian(BigInt(value), 8).forEach((el) => this.write8(el));\n\n        return this;\n    }\n    /**\n     * Write a U128 value into a buffer and shift cursor position by 16.\n     *\n     * @param {bigint} value Value to write.\n     * @returns {this}\n     */\n    write128(value: number | bigint): this {\n        toLittleEndian(BigInt(value), 16).forEach((el) => this.write8(el));\n\n        return this;\n    }\n    /**\n     * Write a U256 value into a buffer and shift cursor position by 16.\n     *\n     * @param {bigint} value Value to write.\n     * @returns {this}\n     */\n    write256(value: number | bigint): this {\n        toLittleEndian(BigInt(value), 32).forEach((el) => this.write8(el));\n\n        return this;\n    }\n    /**\n     * Write a ULEB value into a buffer and shift cursor position by number of bytes\n     * written.\n     * @param {Number} value Value to write.\n     * @returns {this}\n     */\n    writeULEB(value: number): this {\n        ulebEncode(value).forEach((el) => this.write8(el));\n        return this;\n    }\n    /**\n     * Write a vector into a buffer by first writing the vector length and then calling\n     * a callback on each passed value.\n     *\n     * @param {Array<Any>} vector Array of elements to write.\n     * @param {WriteVecCb} cb Callback to call on each element of the vector.\n     * @returns {this}\n     */\n    writeVec(\n        vector: any[],\n        cb: (writer: BcsWriter, el: any, i: number, len: number) => void,\n    ): this {\n        this.writeULEB(vector.length);\n        Array.from(vector).forEach((el, i) => cb(this, el, i, vector.length));\n        return this;\n    }\n\n    /**\n     * Adds support for iterations over the object.\n     * @returns {Uint8Array}\n     */\n    *[Symbol.iterator](): Iterator<number, Iterable<number>> {\n        for (let i = 0; i < this.bytePosition; i++) {\n            yield this.dataView.getUint8(i);\n        }\n        return this.toBytes();\n    }\n\n    /**\n     * Get underlying buffer taking only value bytes (in case initial buffer size was bigger).\n     * @returns {Uint8Array} Resulting bcs.\n     */\n    toBytes(): Uint8Array {\n        return new Uint8Array(this.dataView.buffer.slice(0, this.bytePosition));\n    }\n\n    /**\n     * Represent data as 'hex' or 'base64'\n     * @param encoding Encoding to use: 'base64' or 'hex'\n     */\n    toString(encoding: Encoding): string {\n        return encodeStr(this.toBytes(), encoding);\n    }\n}\n\nfunction toLittleEndian(bigint: bigint, size: number) {\n    const result = new Uint8Array(size);\n    let i = 0;\n    while (bigint > 0) {\n        result[i] = Number(bigint % BigInt(256));\n        bigint = bigint / BigInt(256);\n        i += 1;\n    }\n    return result;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 474, "column": 0}, "map": {"version":3,"sources":["file:///home/anh/to-do-list/node_modules/.pnpm/%40iota%2Bbcs%401.4.0/node_modules/%40iota/bcs/src/bcs-type.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase58, toBase58 } from './b58.js';\nimport { fromBase64, toBase64 } from './b64.js';\nimport { fromHex, toHex } from './hex.js';\nimport { BcsReader } from './reader.js';\nimport { ulebEncode } from './uleb.js';\nimport type { BcsWriterOptions } from './writer.js';\nimport { BcsWriter } from './writer.js';\n\nexport interface BcsTypeOptions<T, Input = T> {\n    name?: string;\n    validate?: (value: Input) => void;\n}\n\nexport class BcsType<T, Input = T> {\n    $inferType!: T;\n    $inferInput!: Input;\n    name: string;\n    read: (reader: BcsReader) => T;\n    serializedSize: (value: Input, options?: BcsWriterOptions) => number | null;\n    validate: (value: Input) => void;\n    #write: (value: Input, writer: BcsWriter) => void;\n    #serialize: (value: Input, options?: BcsWriterOptions) => Uint8Array;\n\n    constructor(\n        options: {\n            name: string;\n            read: (reader: BcsReader) => T;\n            write: (value: Input, writer: BcsWriter) => void;\n            serialize?: (value: Input, options?: BcsWriterOptions) => Uint8Array;\n            serializedSize?: (value: Input) => number | null;\n            validate?: (value: Input) => void;\n        } & BcsTypeOptions<T, Input>,\n    ) {\n        this.name = options.name;\n        this.read = options.read;\n        this.serializedSize = options.serializedSize ?? (() => null);\n        this.#write = options.write;\n        this.#serialize =\n            options.serialize ??\n            ((value, options) => {\n                const writer = new BcsWriter({\n                    initialSize: this.serializedSize(value) ?? undefined,\n                    ...options,\n                });\n                this.#write(value, writer);\n                return writer.toBytes();\n            });\n\n        this.validate = options.validate ?? (() => {});\n    }\n\n    write(value: Input, writer: BcsWriter) {\n        this.validate(value);\n        this.#write(value, writer);\n    }\n\n    serialize(value: Input, options?: BcsWriterOptions) {\n        this.validate(value);\n        return new SerializedBcs(this, this.#serialize(value, options));\n    }\n\n    parse(bytes: Uint8Array): T {\n        const reader = new BcsReader(bytes);\n        return this.read(reader);\n    }\n\n    fromHex(hex: string) {\n        return this.parse(fromHex(hex));\n    }\n\n    fromBase58(b64: string) {\n        return this.parse(fromBase58(b64));\n    }\n\n    fromBase64(b64: string) {\n        return this.parse(fromBase64(b64));\n    }\n\n    transform<T2 = T, Input2 = Input>({\n        name,\n        input,\n        output,\n        validate,\n    }: {\n        input?: (val: Input2) => Input;\n        output?: (value: T) => T2;\n    } & BcsTypeOptions<T2, Input2>) {\n        return new BcsType<T2, Input2>({\n            name: name ?? this.name,\n            read: (reader) => (output ? output(this.read(reader)) : (this.read(reader) as never)),\n            write: (value, writer) => this.#write(input ? input(value) : (value as never), writer),\n            serializedSize: (value) => this.serializedSize(input ? input(value) : (value as never)),\n            serialize: (value, options) =>\n                this.#serialize(input ? input(value) : (value as never), options),\n            validate: (value) => {\n                validate?.(value);\n                this.validate(input ? input(value) : (value as never));\n            },\n        });\n    }\n}\n\nconst SERIALIZED_BCS_BRAND = Symbol.for('@iota/serialized-bcs') as never;\nexport function isSerializedBcs(obj: unknown): obj is SerializedBcs<unknown> {\n    return !!obj && typeof obj === 'object' && (obj as any)[SERIALIZED_BCS_BRAND] === true;\n}\n\nexport class SerializedBcs<T, Input = T> {\n    #schema: BcsType<T, Input>;\n    #bytes: Uint8Array;\n\n    // Used to brand SerializedBcs so that they can be identified, even between multiple copies\n    // of the @iota/bcs package are installed\n    get [SERIALIZED_BCS_BRAND]() {\n        return true;\n    }\n\n    constructor(type: BcsType<T, Input>, schema: Uint8Array) {\n        this.#schema = type;\n        this.#bytes = schema;\n    }\n\n    toBytes() {\n        return this.#bytes;\n    }\n\n    toHex() {\n        return toHex(this.#bytes);\n    }\n\n    toBase64() {\n        return toBase64(this.#bytes);\n    }\n\n    toBase58() {\n        return toBase58(this.#bytes);\n    }\n\n    parse() {\n        return this.#schema.parse(this.#bytes);\n    }\n}\n\nexport function fixedSizeBcsType<T, Input = T>({\n    size,\n    ...options\n}: {\n    name: string;\n    size: number;\n    read: (reader: BcsReader) => T;\n    write: (value: Input, writer: BcsWriter) => void;\n} & BcsTypeOptions<T, Input>) {\n    return new BcsType<T, Input>({\n        ...options,\n        serializedSize: () => size,\n    });\n}\n\nexport function uIntBcsType({\n    readMethod,\n    writeMethod,\n    ...options\n}: {\n    name: string;\n    size: number;\n    readMethod: `read${8 | 16 | 32}`;\n    writeMethod: `write${8 | 16 | 32}`;\n    maxValue: number;\n} & BcsTypeOptions<number, number>) {\n    return fixedSizeBcsType<number>({\n        ...options,\n        read: (reader) => reader[readMethod](),\n        write: (value, writer) => writer[writeMethod](value),\n        validate: (value) => {\n            if (value < 0 || value > options.maxValue) {\n                throw new TypeError(\n                    `Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`,\n                );\n            }\n            options.validate?.(value);\n        },\n    });\n}\n\nexport function bigUIntBcsType({\n    readMethod,\n    writeMethod,\n    ...options\n}: {\n    name: string;\n    size: number;\n    readMethod: `read${64 | 128 | 256}`;\n    writeMethod: `write${64 | 128 | 256}`;\n    maxValue: bigint;\n} & BcsTypeOptions<string, string | number | bigint>) {\n    return fixedSizeBcsType<string, string | number | bigint>({\n        ...options,\n        read: (reader) => reader[readMethod](),\n        write: (value, writer) => writer[writeMethod](BigInt(value)),\n        validate: (val) => {\n            const value = BigInt(val);\n            if (value < 0 || value > options.maxValue) {\n                throw new TypeError(\n                    `Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`,\n                );\n            }\n            options.validate?.(value);\n        },\n    });\n}\n\nexport function dynamicSizeBcsType<T, Input = T>({\n    serialize,\n    ...options\n}: {\n    name: string;\n    read: (reader: BcsReader) => T;\n    serialize: (value: Input, options?: BcsWriterOptions) => Uint8Array;\n} & BcsTypeOptions<T, Input>) {\n    const type = new BcsType<T, Input>({\n        ...options,\n        serialize,\n        write: (value, writer) => {\n            for (const byte of type.serialize(value).toBytes()) {\n                writer.write8(byte);\n            }\n        },\n    });\n\n    return type;\n}\n\nexport function stringLikeBcsType({\n    toBytes,\n    fromBytes,\n    ...options\n}: {\n    name: string;\n    toBytes: (value: string) => Uint8Array;\n    fromBytes: (bytes: Uint8Array) => string;\n    serializedSize?: (value: string) => number | null;\n} & BcsTypeOptions<string>) {\n    return new BcsType<string>({\n        ...options,\n        read: (reader) => {\n            const length = reader.readULEB();\n            const bytes = reader.readBytes(length);\n\n            return fromBytes(bytes);\n        },\n        write: (hex, writer) => {\n            const bytes = toBytes(hex);\n            writer.writeULEB(bytes.length);\n            for (let i = 0; i < bytes.length; i++) {\n                writer.write8(bytes[i]);\n            }\n        },\n        serialize: (value) => {\n            const bytes = toBytes(value);\n            const size = ulebEncode(bytes.length);\n            const result = new Uint8Array(size.length + bytes.length);\n            result.set(size, 0);\n            result.set(bytes, size.length);\n\n            return result;\n        },\n        validate: (value) => {\n            if (typeof value !== 'string') {\n                throw new TypeError(`Invalid ${options.name} value: ${value}. Expected string`);\n            }\n            options.validate?.(value);\n        },\n    });\n}\n\nexport function lazyBcsType<T, Input>(cb: () => BcsType<T, Input>) {\n    let lazyType: BcsType<T, Input> | null = null;\n    function getType() {\n        if (!lazyType) {\n            lazyType = cb();\n        }\n        return lazyType;\n    }\n\n    return new BcsType<T, Input>({\n        name: 'lazy' as never,\n        read: (data) => getType().read(data),\n        serializedSize: (value) => getType().serializedSize(value),\n        write: (value, writer) => getType().write(value, writer),\n        serialize: (value, options) => getType().serialize(value, options).toBytes(),\n    });\n}\n"],"names":["options"],"mappings":"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"}},
    {"offset": {"line": 702, "column": 0}, "map": {"version":3,"sources":["file:///home/anh/to-do-list/node_modules/.pnpm/%40iota%2Bbcs%401.4.0/node_modules/%40iota/bcs/src/bcs.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { BcsTypeOptions } from './bcs-type.js';\nimport {\n    BcsType,\n    bigUIntBcsType,\n    dynamicSizeBcsType,\n    fixedSizeBcsType,\n    lazyBcsType,\n    stringLikeBcsType,\n    uIntBcsType,\n} from './bcs-type.js';\nimport type { EnumInputShape, EnumOutputShape } from './types.js';\nimport { ulebEncode } from './uleb.js';\n\nexport const bcs = {\n    /**\n     * Creates a BcsType that can be used to read and write an 8-bit unsigned integer.\n     * @example\n     * bcs.u8().serialize(255).toBytes() // Uint8Array [ 255 ]\n     */\n    u8(options?: BcsTypeOptions<number>) {\n        return uIntBcsType({\n            name: 'u8',\n            readMethod: 'read8',\n            writeMethod: 'write8',\n            size: 1,\n            maxValue: 2 ** 8 - 1,\n            ...options,\n        });\n    },\n\n    /**\n     * Creates a BcsType that can be used to read and write a 16-bit unsigned integer.\n     * @example\n     * bcs.u16().serialize(65535).toBytes() // Uint8Array [ 255, 255 ]\n     */\n    u16(options?: BcsTypeOptions<number>) {\n        return uIntBcsType({\n            name: 'u16',\n            readMethod: 'read16',\n            writeMethod: 'write16',\n            size: 2,\n            maxValue: 2 ** 16 - 1,\n            ...options,\n        });\n    },\n\n    /**\n     * Creates a BcsType that can be used to read and write a 32-bit unsigned integer.\n     * @example\n     * bcs.u32().serialize(4294967295).toBytes() // Uint8Array [ 255, 255, 255, 255 ]\n     */\n    u32(options?: BcsTypeOptions<number>) {\n        return uIntBcsType({\n            name: 'u32',\n            readMethod: 'read32',\n            writeMethod: 'write32',\n            size: 4,\n            maxValue: 2 ** 32 - 1,\n            ...options,\n        });\n    },\n\n    /**\n     * Creates a BcsType that can be used to read and write a 64-bit unsigned integer.\n     * @example\n     * bcs.u64().serialize(1).toBytes() // Uint8Array [ 1, 0, 0, 0, 0, 0, 0, 0 ]\n     */\n    u64(options?: BcsTypeOptions<string, number | bigint | string>) {\n        return bigUIntBcsType({\n            name: 'u64',\n            readMethod: 'read64',\n            writeMethod: 'write64',\n            size: 8,\n            maxValue: 2n ** 64n - 1n,\n            ...options,\n        });\n    },\n\n    /**\n     * Creates a BcsType that can be used to read and write a 128-bit unsigned integer.\n     * @example\n     * bcs.u128().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n     */\n    u128(options?: BcsTypeOptions<string, number | bigint | string>) {\n        return bigUIntBcsType({\n            name: 'u128',\n            readMethod: 'read128',\n            writeMethod: 'write128',\n            size: 16,\n            maxValue: 2n ** 128n - 1n,\n            ...options,\n        });\n    },\n\n    /**\n     * Creates a BcsType that can be used to read and write a 256-bit unsigned integer.\n     * @example\n     * bcs.u256().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n     */\n    u256(options?: BcsTypeOptions<string, number | bigint | string>) {\n        return bigUIntBcsType({\n            name: 'u256',\n            readMethod: 'read256',\n            writeMethod: 'write256',\n            size: 32,\n            maxValue: 2n ** 256n - 1n,\n            ...options,\n        });\n    },\n\n    /**\n     * Creates a BcsType that can be used to read and write boolean values.\n     * @example\n     * bcs.bool().serialize(true).toBytes() // Uint8Array [ 1 ]\n     */\n    bool(options?: BcsTypeOptions<boolean>) {\n        return fixedSizeBcsType<boolean>({\n            name: 'bool',\n            size: 1,\n            read: (reader) => reader.read8() === 1,\n            write: (value, writer) => writer.write8(value ? 1 : 0),\n            ...options,\n            validate: (value) => {\n                options?.validate?.(value);\n                if (typeof value !== 'boolean') {\n                    throw new TypeError(`Expected boolean, found ${typeof value}`);\n                }\n            },\n        });\n    },\n\n    /**\n     * Creates a BcsType that can be used to read and write unsigned LEB encoded integers\n     * @example\n     *\n     */\n    uleb128(options?: BcsTypeOptions<number>) {\n        return dynamicSizeBcsType<number>({\n            name: 'uleb128',\n            read: (reader) => reader.readULEB(),\n            serialize: (value) => {\n                return Uint8Array.from(ulebEncode(value));\n            },\n            ...options,\n        });\n    },\n\n    /**\n     * Creates a BcsType representing a fixed length byte array\n     * @param size The number of bytes this types represents\n     * @example\n     * bcs.bytes(3).serialize(new Uint8Array([1, 2, 3])).toBytes() // Uint8Array [1, 2, 3]\n     */\n    bytes<T extends number>(size: T, options?: BcsTypeOptions<Uint8Array, Iterable<number>>) {\n        return fixedSizeBcsType<Uint8Array>({\n            name: `bytes[${size}]`,\n            size,\n            read: (reader) => reader.readBytes(size),\n            write: (value, writer) => {\n                for (let i = 0; i < size; i++) {\n                    writer.write8(value[i] ?? 0);\n                }\n            },\n            ...options,\n            validate: (value) => {\n                options?.validate?.(value);\n                if (!value || typeof value !== 'object' || !('length' in value)) {\n                    throw new TypeError(`Expected array, found ${typeof value}`);\n                }\n                if (value.length !== size) {\n                    throw new TypeError(`Expected array of length ${size}, found ${value.length}`);\n                }\n            },\n        });\n    },\n\n    /**\n     * Creates a BcsType representing a variable length byte array\n     *\n     * @example\n     * bcs.byteVector().serialize([1, 2, 3]).toBytes() // Uint8Array [3, 1, 2, 3]\n     */\n    byteVector(options?: BcsTypeOptions<Uint8Array, Iterable<number>>) {\n        return new BcsType<Uint8Array, Iterable<number>>({\n            name: `bytesVector`,\n            read: (reader) => {\n                const length = reader.readULEB();\n\n                return reader.readBytes(length);\n            },\n            write: (value, writer) => {\n                const array = new Uint8Array(value);\n                writer.writeULEB(array.length);\n                for (let i = 0; i < array.length; i++) {\n                    writer.write8(array[i] ?? 0);\n                }\n            },\n            ...options,\n            serializedSize: (value) => {\n                const length = 'length' in value ? (value.length as number) : null;\n                return length == null ? null : ulebEncode(length).length + length;\n            },\n            validate: (value) => {\n                options?.validate?.(value);\n                if (!value || typeof value !== 'object' || !('length' in value)) {\n                    throw new TypeError(`Expected array, found ${typeof value}`);\n                }\n            },\n        });\n    },\n\n    /**\n     * Creates a BcsType that can ser/de string values.  Strings will be UTF-8 encoded\n     * @example\n     * bcs.string().serialize('a').toBytes() // Uint8Array [ 1, 97 ]\n     */\n    string(options?: BcsTypeOptions<string>) {\n        return stringLikeBcsType({\n            name: 'string',\n            toBytes: (value) => new TextEncoder().encode(value),\n            fromBytes: (bytes) => new TextDecoder().decode(bytes),\n            ...options,\n        });\n    },\n\n    /**\n     * Creates a BcsType that represents a fixed length array of a given type\n     * @param size The number of elements in the array\n     * @param type The BcsType of each element in the array\n     * @example\n     * bcs.fixedArray(3, bcs.u8()).serialize([1, 2, 3]).toBytes() // Uint8Array [ 1, 2, 3 ]\n     */\n    fixedArray<T, Input>(\n        size: number,\n        type: BcsType<T, Input>,\n        options?: BcsTypeOptions<T[], Iterable<Input> & { length: number }>,\n    ) {\n        return new BcsType<T[], Iterable<Input> & { length: number }>({\n            name: `${type.name}[${size}]`,\n            read: (reader) => {\n                const result: T[] = new Array(size);\n                for (let i = 0; i < size; i++) {\n                    result[i] = type.read(reader);\n                }\n                return result;\n            },\n            write: (value, writer) => {\n                for (const item of value) {\n                    type.write(item, writer);\n                }\n            },\n            ...options,\n            validate: (value) => {\n                options?.validate?.(value);\n                if (!value || typeof value !== 'object' || !('length' in value)) {\n                    throw new TypeError(`Expected array, found ${typeof value}`);\n                }\n                if (value.length !== size) {\n                    throw new TypeError(`Expected array of length ${size}, found ${value.length}`);\n                }\n            },\n        });\n    },\n\n    /**\n     * Creates a BcsType representing an optional value\n     * @param type The BcsType of the optional value\n     * @example\n     * bcs.option(bcs.u8()).serialize(null).toBytes() // Uint8Array [ 0 ]\n     * bcs.option(bcs.u8()).serialize(1).toBytes() // Uint8Array [ 1, 1 ]\n     */\n    option<T, Input>(type: BcsType<T, Input>) {\n        return bcs\n            .enum(`Option<${type.name}>`, {\n                None: null,\n                Some: type,\n            })\n            .transform({\n                input: (value: Input | null | undefined) => {\n                    if (value == null) {\n                        return { None: true };\n                    }\n\n                    return { Some: value };\n                },\n                output: (value) => {\n                    if (value.$kind === 'Some') {\n                        return value.Some;\n                    }\n\n                    return null;\n                },\n            });\n    },\n\n    /**\n     * Creates a BcsType representing a variable length vector of a given type\n     * @param type The BcsType of each element in the vector\n     *\n     * @example\n     * bcs.vector(bcs.u8()).toBytes([1, 2, 3]) // Uint8Array [ 3, 1, 2, 3 ]\n     */\n    vector<T, Input>(\n        type: BcsType<T, Input>,\n        options?: BcsTypeOptions<T[], Iterable<Input> & { length: number }>,\n    ) {\n        return new BcsType<T[], Iterable<Input> & { length: number }>({\n            name: `vector<${type.name}>`,\n            read: (reader) => {\n                const length = reader.readULEB();\n                const result: T[] = new Array(length);\n                for (let i = 0; i < length; i++) {\n                    result[i] = type.read(reader);\n                }\n                return result;\n            },\n            write: (value, writer) => {\n                writer.writeULEB(value.length);\n                for (const item of value) {\n                    type.write(item, writer);\n                }\n            },\n            ...options,\n            validate: (value) => {\n                options?.validate?.(value);\n                if (!value || typeof value !== 'object' || !('length' in value)) {\n                    throw new TypeError(`Expected array, found ${typeof value}`);\n                }\n            },\n        });\n    },\n\n    /**\n     * Creates a BcsType representing a tuple of a given set of types\n     * @param types The BcsTypes for each element in the tuple\n     *\n     * @example\n     * const tuple = bcs.tuple([bcs.u8(), bcs.string(), bcs.bool()])\n     * tuple.serialize([1, 'a', true]).toBytes() // Uint8Array [ 1, 1, 97, 1 ]\n     */\n    tuple<const Types extends readonly BcsType<any>[]>(\n        types: Types,\n        options?: BcsTypeOptions<\n            {\n                -readonly [K in keyof Types]: Types[K] extends BcsType<infer T, any> ? T : never;\n            },\n            {\n                [K in keyof Types]: Types[K] extends BcsType<any, infer T> ? T : never;\n            }\n        >,\n    ) {\n        return new BcsType<\n            {\n                -readonly [K in keyof Types]: Types[K] extends BcsType<infer T, any> ? T : never;\n            },\n            {\n                [K in keyof Types]: Types[K] extends BcsType<any, infer T> ? T : never;\n            }\n        >({\n            name: `(${types.map((t) => t.name).join(', ')})`,\n            serializedSize: (values) => {\n                let total = 0;\n                for (let i = 0; i < types.length; i++) {\n                    const size = types[i].serializedSize(values[i]);\n                    if (size == null) {\n                        return null;\n                    }\n\n                    total += size;\n                }\n\n                return total;\n            },\n            read: (reader) => {\n                const result: unknown[] = [];\n                for (const type of types) {\n                    result.push(type.read(reader));\n                }\n                return result as never;\n            },\n            write: (value, writer) => {\n                for (let i = 0; i < types.length; i++) {\n                    types[i].write(value[i], writer);\n                }\n            },\n            ...options,\n            validate: (value) => {\n                options?.validate?.(value);\n                if (!Array.isArray(value)) {\n                    throw new TypeError(`Expected array, found ${typeof value}`);\n                }\n                if (value.length !== types.length) {\n                    throw new TypeError(\n                        `Expected array of length ${types.length}, found ${value.length}`,\n                    );\n                }\n            },\n        });\n    },\n\n    /**\n     * Creates a BcsType representing a struct of a given set of fields\n     * @param name The name of the struct\n     * @param fields The fields of the struct. The order of the fields affects how data is serialized and deserialized\n     *\n     * @example\n     * const struct = bcs.struct('MyStruct', {\n     *  a: bcs.u8(),\n     *  b: bcs.string(),\n     * })\n     * struct.serialize({ a: 1, b: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n     */\n    struct<T extends Record<string, BcsType<any>>>(\n        name: string,\n        fields: T,\n        options?: Omit<\n            BcsTypeOptions<\n                {\n                    [K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never;\n                },\n                {\n                    [K in keyof T]: T[K] extends BcsType<any, infer U> ? U : never;\n                }\n            >,\n            'name'\n        >,\n    ) {\n        const canonicalOrder = Object.entries(fields);\n\n        return new BcsType<\n            {\n                [K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never;\n            },\n            {\n                [K in keyof T]: T[K] extends BcsType<any, infer U> ? U : never;\n            }\n        >({\n            name,\n            serializedSize: (values) => {\n                let total = 0;\n                for (const [field, type] of canonicalOrder) {\n                    const size = type.serializedSize(values[field]);\n                    if (size == null) {\n                        return null;\n                    }\n\n                    total += size;\n                }\n\n                return total;\n            },\n            read: (reader) => {\n                const result: Record<string, unknown> = {};\n                for (const [field, type] of canonicalOrder) {\n                    result[field] = type.read(reader);\n                }\n\n                return result as never;\n            },\n            write: (value, writer) => {\n                for (const [field, type] of canonicalOrder) {\n                    type.write(value[field], writer);\n                }\n            },\n            ...options,\n            validate: (value) => {\n                options?.validate?.(value);\n                if (typeof value !== 'object' || value == null) {\n                    throw new TypeError(`Expected object, found ${typeof value}`);\n                }\n            },\n        });\n    },\n\n    /**\n     * Creates a BcsType representing an enum of a given set of options\n     * @param name The name of the enum\n     * @param values The values of the enum. The order of the values affects how data is serialized and deserialized.\n     * null can be used to represent a variant with no data.\n     *\n     * @example\n     * const enum = bcs.enum('MyEnum', {\n     *   A: bcs.u8(),\n     *   B: bcs.string(),\n     *   C: null,\n     * })\n     * enum.serialize({ A: 1 }).toBytes() // Uint8Array [ 0, 1 ]\n     * enum.serialize({ B: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n     * enum.serialize({ C: true }).toBytes() // Uint8Array [ 2 ]\n     */\n    enum<T extends Record<string, BcsType<any> | null>>(\n        name: string,\n        values: T,\n        options?: Omit<\n            BcsTypeOptions<\n                EnumOutputShape<{\n                    [K in keyof T]: T[K] extends BcsType<infer U, any> ? U : true;\n                }>,\n                EnumInputShape<{\n                    [K in keyof T]: T[K] extends BcsType<any, infer U>\n                        ? U\n                        : boolean | object | null;\n                }>\n            >,\n            'name'\n        >,\n    ) {\n        const canonicalOrder = Object.entries(values as object);\n        return new BcsType<\n            EnumOutputShape<{\n                [K in keyof T]: T[K] extends BcsType<infer U, any> ? U : true;\n            }>,\n            EnumInputShape<{\n                [K in keyof T]: T[K] extends BcsType<any, infer U> ? U : boolean | object | null;\n            }>\n        >({\n            name,\n            read: (reader) => {\n                const index = reader.readULEB();\n\n                const enumEntry = canonicalOrder[index];\n                if (!enumEntry) {\n                    throw new TypeError(`Unknown value ${index} for enum ${name}`);\n                }\n\n                const [kind, type] = enumEntry;\n\n                return {\n                    [kind]: type?.read(reader) ?? true,\n                    $kind: kind,\n                } as never;\n            },\n            write: (value, writer) => {\n                const [name, val] = Object.entries(value).filter(([name]) =>\n                    Object.hasOwn(values, name),\n                )[0];\n\n                for (let i = 0; i < canonicalOrder.length; i++) {\n                    const [optionName, optionType] = canonicalOrder[i];\n                    if (optionName === name) {\n                        writer.writeULEB(i);\n                        optionType?.write(val, writer);\n                        return;\n                    }\n                }\n            },\n            ...options,\n            validate: (value) => {\n                options?.validate?.(value);\n                if (typeof value !== 'object' || value == null) {\n                    throw new TypeError(`Expected object, found ${typeof value}`);\n                }\n\n                const keys = Object.keys(value).filter(\n                    (k) => value[k] !== undefined && Object.hasOwn(values, k),\n                );\n\n                if (keys.length !== 1) {\n                    throw new TypeError(\n                        `Expected object with one key, but found ${keys.length} for type ${name}}`,\n                    );\n                }\n\n                const [variant] = keys;\n\n                if (!Object.hasOwn(values, variant)) {\n                    throw new TypeError(`Invalid enum variant ${variant}`);\n                }\n            },\n        });\n    },\n\n    /**\n     * Creates a BcsType representing a map of a given key and value type\n     * @param keyType The BcsType of the key\n     * @param valueType The BcsType of the value\n     * @example\n     * const map = bcs.map(bcs.u8(), bcs.string())\n     * map.serialize(new Map([[2, 'a']])).toBytes() // Uint8Array [ 1, 2, 1, 97 ]\n     */\n    map<K, V, InputK = K, InputV = V>(keyType: BcsType<K, InputK>, valueType: BcsType<V, InputV>) {\n        return bcs.vector(bcs.tuple([keyType, valueType])).transform({\n            name: `Map<${keyType.name}, ${valueType.name}>`,\n            input: (value: Map<InputK, InputV>) => {\n                return [...value.entries()];\n            },\n            output: (value) => {\n                const result = new Map<K, V>();\n                for (const [key, val] of value) {\n                    result.set(key, val);\n                }\n                return result;\n            },\n        });\n    },\n\n    /**\n     * Creates a BcsType that wraps another BcsType which is lazily evaluated. This is useful for creating recursive types.\n     * @param cb A callback that returns the BcsType\n     */\n    lazy<T extends BcsType<any>>(cb: () => T): T {\n        return lazyBcsType(cb) as T;\n    },\n};\n"],"names":["name"],"mappings":"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"}}]
}